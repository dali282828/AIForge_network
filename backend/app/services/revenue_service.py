"""
Revenue Service for tracking and distributing revenue
Handles revenue sharing between platform and model creators
"""
from typing import Dict, List, Optional
from decimal import Decimal
from datetime import datetime, timedelta
from sqlalchemy.orm import Session
from sqlalchemy import func, and_
from app.models.payment import Payment, PaymentStatus, PaymentType
from app.models.subscription import Subscription
from app.models.api_service import APIService, APIRequest
from app.models.model import Model
from app.core.config import settings
from app.services.payment_service import PaymentService

class RevenueService:
    """Service for managing revenue tracking and distribution"""
    
    @staticmethod
    def calculate_monthly_revenue(db: Session, year: int, month: int) -> Dict:
        """Calculate total revenue for a specific month"""
        start_date = datetime(year, month, 1)
        if month == 12:
            end_date = datetime(year + 1, 1, 1)
        else:
            end_date = datetime(year, month + 1, 1)
        
        # Get all confirmed payments in the period
        payments = db.query(Payment).filter(
            Payment.status == PaymentStatus.CONFIRMED,
            Payment.created_at >= start_date,
            Payment.created_at < end_date
        ).all()
        
        total_revenue = Decimal("0.00")
        platform_fees = Decimal("0.00")
        subscription_revenue = Decimal("0.00")
        job_revenue = Decimal("0.00")
        model_revenue = Decimal("0.00")
        api_revenue = Decimal("0.00")
        
        for payment in payments:
            total_revenue += payment.amount
            platform_fees += payment.platform_fee_amount
            
            if payment.payment_type == PaymentType.SUBSCRIPTION:
                subscription_revenue += payment.amount
            elif payment.payment_type == PaymentType.JOB:
                job_revenue += payment.amount
            elif payment.payment_type == PaymentType.MODEL_PURCHASE:
                model_revenue += payment.amount
            elif payment.payment_type in [PaymentType.API_SUBSCRIPTION, PaymentType.API_USAGE]:
                api_revenue += payment.amount
        
        return {
            "period": f"{year}-{month:02d}",
            "total_revenue": str(total_revenue),
            "platform_fees": str(platform_fees),
            "net_revenue": str(total_revenue - platform_fees),
            "by_type": {
                "subscriptions": str(subscription_revenue),
                "jobs": str(job_revenue),
                "models": str(model_revenue),
                "api": str(api_revenue)
            }
        }
    
    @staticmethod
    def calculate_model_usage_revenue(db: Session, model_id: int, year: int, month: int) -> Dict:
        """Calculate revenue generated by a specific model (NET revenue after platform fee)"""
        start_date = datetime(year, month, 1)
        if month == 12:
            end_date = datetime(year + 1, 1, 1)
        else:
            end_date = datetime(year, month + 1, 1)
        
        # Get API services for this model
        services = db.query(APIService).filter(APIService.model_id == model_id).all()
        service_ids = [s.id for s in services]
        
        if not service_ids:
            return {
                "model_id": model_id,
                "period": f"{year}-{month:02d}",
                "total_revenue": "0.00",
                "gross_revenue": "0.00",
                "platform_fee": "0.00",
                "requests": 0,
                "tokens_used": 0
            }
        
        # Get API requests for these services
        requests = db.query(APIRequest).filter(
            APIRequest.service_id.in_(service_ids),
            APIRequest.created_at >= start_date,
            APIRequest.created_at < end_date
        ).all()
        
        # Calculate platform fee for API usage (10%)
        platform_fee_percent = Decimal(str(settings.PLATFORM_FEE_API))
        
        gross_revenue = Decimal("0.00")
        total_requests = len(requests)
        total_tokens = sum(r.tokens_used for r in requests)
        
        for req in requests:
            gross_revenue += req.cost
        
        # Calculate platform fee and net revenue
        platform_fee = gross_revenue * platform_fee_percent
        net_revenue = gross_revenue - platform_fee
        
        return {
            "model_id": model_id,
            "period": f"{year}-{month:02d}",
            "total_revenue": str(net_revenue),  # NET revenue after platform fee
            "gross_revenue": str(gross_revenue),  # Gross revenue before platform fee
            "platform_fee": str(platform_fee),  # Platform fee deducted
            "requests": total_requests,
            "tokens_used": total_tokens
        }
    
    @staticmethod
    def calculate_subscription_revenue_distribution(
        db: Session,
        year: int,
        month: int
    ) -> Dict:
        """
        Calculate how subscription revenue should be distributed to model creators
        Based on usage: 70% of subscription revenue goes to model pool, distributed by usage
        """
        start_date = datetime(year, month, 1)
        if month == 12:
            end_date = datetime(year + 1, 1, 1)
        else:
            end_date = datetime(year, month + 1, 1)
        
        # Get all subscription payments
        subscription_payments = db.query(Payment).filter(
            Payment.payment_type == PaymentType.SUBSCRIPTION,
            Payment.status == PaymentStatus.CONFIRMED,
            Payment.created_at >= start_date,
            Payment.created_at < end_date
        ).all()
        
        total_subscription_revenue = sum(p.amount for p in subscription_payments)
        platform_fee_percent = Decimal(str(settings.PLATFORM_FEE_SUBSCRIPTION))
        model_pool_percent = Decimal("1.0") - platform_fee_percent
        
        platform_fee = total_subscription_revenue * platform_fee_percent
        model_pool = total_subscription_revenue * model_pool_percent
        
        # Calculate model usage for the period
        api_requests = db.query(APIRequest).filter(
            APIRequest.created_at >= start_date,
            APIRequest.created_at < end_date
        ).all()
        
        # Group by model
        model_usage = {}
        total_tokens = Decimal("0.00")
        
        for req in api_requests:
            service = db.query(APIService).filter(APIService.id == req.service_id).first()
            if service:
                model_id = service.model_id
                if model_id not in model_usage:
                    model_usage[model_id] = {
                        "requests": 0,
                        "tokens": 0,
                        "revenue": Decimal("0.00")
                    }
                model_usage[model_id]["requests"] += 1
                model_usage[model_id]["tokens"] += req.tokens_used
                model_usage[model_id]["revenue"] += req.cost
                total_tokens += req.tokens_used
        
        # Distribute model pool based on usage
        distribution = []
        for model_id, usage in model_usage.items():
            if total_tokens > 0:
                usage_percent = Decimal(str(usage["tokens"])) / total_tokens
                revenue_share = model_pool * usage_percent
                
                model = db.query(Model).filter(Model.id == model_id).first()
                distribution.append({
                    "model_id": model_id,
                    "model_name": model.name if model else "Unknown",
                    "owner_id": model.owner_id if model else None,
                    "usage_percent": float(usage_percent * 100),
                    "tokens_used": usage["tokens"],
                    "requests": usage["requests"],
                    "revenue_share": str(revenue_share)
                })
        
        # Sort by revenue share
        distribution.sort(key=lambda x: Decimal(x["revenue_share"]), reverse=True)
        
        return {
            "period": f"{year}-{month:02d}",
            "total_subscription_revenue": str(total_subscription_revenue),
            "platform_fee": str(platform_fee),
            "model_pool": str(model_pool),
            "distribution": distribution
        }
    
    @staticmethod
    def get_model_creator_earnings(
        db: Session,
        user_id: int,
        year: Optional[int] = None,
        month: Optional[int] = None
    ) -> Dict:
        """Get total earnings for a model creator"""
        # Get all models owned by user
        models = db.query(Model).filter(Model.owner_id == user_id).all()
        model_ids = [m.id for m in models]
        
        if not model_ids:
            return {
                "user_id": user_id,
                "total_earnings": "0.00",
                "by_model": []
            }
        
        # Get API services for these models
        services = db.query(APIService).filter(APIService.model_id.in_(model_ids)).all()
        service_ids = [s.id for s in services]
        
        if not service_ids:
            return {
                "user_id": user_id,
                "total_earnings": "0.00",
                "by_model": []
            }
        
        # Build query for API requests
        query = db.query(APIRequest).filter(APIRequest.service_id.in_(service_ids))
        
        if year and month:
            start_date = datetime(year, month, 1)
            if month == 12:
                end_date = datetime(year + 1, 1, 1)
            else:
                end_date = datetime(year, month + 1, 1)
            query = query.filter(
                APIRequest.created_at >= start_date,
                APIRequest.created_at < end_date
            )
        
        requests = query.all()
        
        # Calculate earnings by model
        earnings_by_model = {}
        total_earnings = Decimal("0.00")
        
        for req in requests:
            service = db.query(APIService).filter(APIService.id == req.service_id).first()
            if service:
                model_id = service.model_id
                if model_id not in earnings_by_model:
                    earnings_by_model[model_id] = {
                        "model_id": model_id,
                        "model_name": None,
                        "revenue": Decimal("0.00"),
                        "requests": 0
                    }
                earnings_by_model[model_id]["revenue"] += req.cost
                earnings_by_model[model_id]["requests"] += 1
                total_earnings += req.cost
        
        # Add model names
        for model_id, data in earnings_by_model.items():
            model = db.query(Model).filter(Model.id == model_id).first()
            if model:
                data["model_name"] = model.name
        
        return {
            "user_id": user_id,
            "period": f"{year}-{month:02d}" if year and month else "all",
            "total_earnings": str(total_earnings),
            "by_model": list(earnings_by_model.values())
        }
    
    @staticmethod
    def get_platform_revenue_summary(db: Session) -> Dict:
        """Get overall platform revenue summary"""
        # Total revenue
        total_payments = db.query(func.sum(Payment.amount)).filter(
            Payment.status == PaymentStatus.CONFIRMED
        ).scalar() or Decimal("0.00")
        
        total_platform_fees = db.query(func.sum(Payment.platform_fee_amount)).filter(
            Payment.status == PaymentStatus.CONFIRMED
        ).scalar() or Decimal("0.00")
        
        # By type
        subscription_revenue = db.query(func.sum(Payment.amount)).filter(
            Payment.payment_type == PaymentType.SUBSCRIPTION,
            Payment.status == PaymentStatus.CONFIRMED
        ).scalar() or Decimal("0.00")
        
        job_revenue = db.query(func.sum(Payment.amount)).filter(
            Payment.payment_type == PaymentType.JOB,
            Payment.status == PaymentStatus.CONFIRMED
        ).scalar() or Decimal("0.00")
        
        model_revenue = db.query(func.sum(Payment.amount)).filter(
            Payment.payment_type == PaymentType.MODEL_PURCHASE,
            Payment.status == PaymentStatus.CONFIRMED
        ).scalar() or Decimal("0.00")
        
        api_revenue = db.query(func.sum(Payment.amount)).filter(
            Payment.payment_type.in_([PaymentType.API_SUBSCRIPTION, PaymentType.API_USAGE]),
            Payment.status == PaymentStatus.CONFIRMED
        ).scalar() or Decimal("0.00")
        
        return {
            "total_revenue": str(total_payments),
            "total_platform_fees": str(total_platform_fees),
            "net_revenue": str(total_payments - total_platform_fees),
            "by_type": {
                "subscriptions": str(subscription_revenue),
                "jobs": str(job_revenue),
                "models": str(model_revenue),
                "api": str(api_revenue)
            }
        }

